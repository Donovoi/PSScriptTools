examples:
- name: EXAMPLE 1
  preCode: ''
  code: PS C:\> get-service -displayname windows* | out-conditionalcolor -propertyconditions @{Stopped='Red'} -property Status
  postCode: Get all services where the displayname starts with windows and display stopped services in red.
- name: EXAMPLE 2
  preCode: ''
  code: PS C:\> get-service -displayname windows* | out-conditionalcolor @{Stopped='Red'} status -ov winstop
  postCode: Repeat the previous example, but also save the output to the variable winstop. When you look at $Winstop you'll see the services, but they won't be colorized. This example uses the parameters positionally.
- name: EXAMPLE 3
  preCode: ''
  code: >-
    PS C:\> get-eventlog system -newest 50 | out-conditionalcolor @{error='red';warning='yellow'}

    Enter a property name: entrytype
  postCode: Get the newest 50 entries from the System event log. Display errors in red and warnings in yellow. If you don't specify a property you will be prompted.
- name: EXAMPLE 4
  preCode: ''
  code: PS C:\> $c =[ordered]@{{$psitem.length -ge 1mb}='red';{$psitem.length -ge 500KB}='yellow';{$psitem.length -ge 100KB}='cyan'}
  postCode: The first command creates an ordered hashtable based on the Length property.
- name: EXAMPLE 5
  preCode: ''
  code: PS C:\> dir c:\scripts\*.doc,c:\scripts\*.pdf,c:\scripts\*.xml |  out-conditionalcolor $c
  postCode: The next command uses it to get certain file types in the scripts folder and display the selected properties in color depending on the file size.
inputs:
- type: System.Management.Automation.PSObject[]
  description: ''
links:
- href: https://github.com/jdhitsolutions/PSScriptTools/blob/master/docs/Out-ConditionalColor.md
  text: 'Online Version:'
- href: ''
  text: About_Hash_Tables
module:
  name: PSScriptTools
name: Out-ConditionalColor
notes: >-
  Learn more about PowerShell: http://jdhitsolutions.com/blog/essential-powershell-resources/

  Originally published at: http://jdhitsolutions.com/blog/powershell/3462/friday-fun-out-conditionalcolor/
optionalParameters: []
outputs:
- type: System.Object
  description: ''
requiredParameters:
- name: Conditions
  aliases: []
  defaultValue: None
  description: Use an ordered hashtable for more complex processing. See examples.
  parameterValueGroup: []
  pipelineInput: False
  position: 0
  type: OrderedDictionary
- name: InputObject
  aliases: []
  defaultValue: None
  description: Output from a PowerShell expression that you want to colorize.
  parameterValueGroup: []
  pipelineInput: True (ByValue)
  position: Named
  type: PSObject[]
- name: Property
  aliases: []
  defaultValue: None
  description: When using a simple hash table, specify the property to compare which will be done by using the -eq operator.
  parameterValueGroup: []
  pipelineInput: False
  position: Named
  type: String
- name: PropertyConditions
  aliases: []
  defaultValue: None
  description: Use a simple hashtable for basic processing or an ordered hash table for complex.
  parameterValueGroup: []
  pipelineInput: False
  position: 0
  type: Hashtable
remarks: >-
  This command is designed to take pipeline input and display it in a colorized format, based on a set of conditions. Unlike Write-Host which doesn't write to the pipeline, this command will write to the pipeline. You can get colorized data and save the output to a variable at the same time, although you'll need to use the common OutVariable parameter (see examples).

  The default behavior is to use a hash table with a property name and color. The color must be one of the standard console colors used with Write-Host.

      $c = @{Stopped='Red';Running='Green'}

  You can then pipe an expression to this command, specifying a property name and the hash table. If the property matches the key name, the output for that object will be colored using the corresponding hash table value.

      get-service -displayname windows* | out-conditionalcolor $c -property status

  Or you can do more complex processing with an ordered hash table constructed using this format:

      [ordered]@{ <comparison scriptblock> = <color>}

  The comparison scriptblock can use $PSitem.

      $h=[ordered]@{         {$psitem.ws -gt 500mb}='red'         {$psitem.ws -gt 300mb}='yellow'         {$psitem.ws -gt 200mb}='cyan'     }

      get-process | out-conditionalcolor $h

  When doing a complex comparison you must use an [ordered] hashtable as each key will be processed in order using an If/ElseIf statement.

  This command should be the last part of any pipelined expression. If you pipe to anything else, such as Sort-Object, you will lose your color formatting. Do any other sorting or filtering before piping to this command.

  This command works best in the PowerShell console. It won't do anything in the PowerShell ISE.

  LIMITATIONS

  Due to the nature of PowerShell's formatting system there are some limitations with this command. If the first item in your output matches one of your conditions, any text before it, such as headers, will also be colorized. This command will have no affect if the incoming object does not have a defined format view. This means you can't pipe custom objects or something using Select-Object that only includes selected properties to this command.
summary: Display colorized pipelined output.
syntaxes:
- parameterValueGroup: conditions
  parameters:
  - Conditions
  - InputObject
- parameterValueGroup: property
  parameters:
  - PropertyConditions
  - InputObject
  - Property
